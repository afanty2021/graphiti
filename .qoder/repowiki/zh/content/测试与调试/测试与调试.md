# 测试与调试

<cite>
**本文档引用的文件**   
- [pytest.ini](file://pytest.ini)
- [conftest.py](file://conftest.py)
- [test_graphiti_int.py](file://tests/test_graphiti_int.py)
- [helpers_test.py](file://tests/helpers_test.py)
- [run_tests.py](file://mcp_server/tests/run_tests.py)
- [test_integration.py](file://mcp_server/tests/test_integration.py)
- [test_comprehensive_integration.py](file://mcp_server/tests/test_comprehensive_integration.py)
- [docker-compose.test.yml](file://docker-compose.test.yml)
</cite>

## 目录
1. [测试策略](#测试策略)
2. [运行测试套件](#运行测试套件)
3. [测试夹具](#测试夹具)
4. [调试技巧](#调试技巧)
5. [常见错误诊断](#常见错误诊断)
6. [性能剖析与内存泄漏检测](#性能剖析与内存泄漏检测)

## 测试策略

本项目采用分层测试策略，包括单元测试、集成测试和端到端测试，以确保系统的稳定性和可靠性。

**单元测试**：针对单个函数或类进行测试，验证其在隔离环境下的行为。这些测试通常使用模拟对象（mocks）来替代外部依赖，确保测试的快速和可重复性。

**集成测试**：验证多个组件之间的交互，特别是与外部服务（如数据库、LLM API）的集成。文件 `test_graphiti_int.py` 包含了集成测试用例，通过 `pytest.mark.integration` 标记来标识。这些测试会实际连接到数据库并执行完整的操作流程。

**端到端测试**：模拟真实用户场景，从API调用到数据存储和检索的完整流程。`mcp_server/tests/test_integration.py` 和 `mcp_server/tests/test_comprehensive_integration.py` 提供了HTTP/SSE和stdio传输模式下的端到端测试。

**Section sources**
- [test_graphiti_int.py](file://tests/test_graphiti_int.py#L28-L29)
- [mcp_server/tests/test_integration.py](file://mcp_server/tests/test_integration.py#L3-L5)
- [mcp_server/tests/test_comprehensive_integration.py](file://mcp_server/tests/test_comprehensive_integration.py#L3-L4)

## 运行测试套件

使用 `pytest` 命令运行测试套件。项目根目录下的 `pytest.ini` 文件配置了测试运行器的默认行为。

运行所有测试：
```bash
pytest
```

运行特定测试文件：
```bash
pytest tests/test_graphiti_int.py
```

运行标记为集成测试的测试：
```bash
pytest -m integration
```

在 `mcp_server` 目录下，可以使用 `run_tests.py` 脚本来运行测试，它提供了更多的选项和配置：
```bash
python run_tests.py smoke
python run_tests.py integration --parallel 4
python run_tests.py stress --database neo4j
python run_tests.py all --coverage
```

**pytest.ini** 配置文件定义了测试标记和异步支持：
```ini
[pytest]
markers =
    integration: marks tests as integration tests
asyncio_default_fixture_loop_scope = function
asyncio_mode = auto
```

**Section sources**
- [pytest.ini](file://pytest.ini#L1-L6)
- [mcp_server/tests/run_tests.py](file://mcp_server/tests/run_tests.py#L227-L342)

## 测试夹具

测试夹具（fixtures）用于设置测试环境和提供测试数据。`conftest.py` 文件定义了全局可用的夹具。

在项目根目录的 `conftest.py` 中，定义了 `graph_driver` 和 `mock_embedder` 夹具，它们在多个测试文件中被重用。`graph_driver` 夹具根据环境变量创建不同类型的图数据库驱动（Neo4j, FalkorDB, Kuzu），并确保在测试前后清理数据。

```python
@pytest.fixture(params=drivers)
async def graph_driver(request):
    driver = request.param
    graph_driver = get_driver(driver)
    await clear_data(graph_driver, [group_id, group_id_2])
    try:
        yield graph_driver
    finally:
        await graph_driver.close()
```

`mock_embedder` 夹具创建了一个模拟的嵌入模型，返回预定义的随机嵌入向量，避免了对实际LLM API的调用。

在 `mcp_server/tests/conftest.py` 中，定义了 `config` 夹具，为MCP服务器测试提供默认配置。

**Section sources**
- [conftest.py](file://conftest.py#L8-L10)
- [helpers_test.py](file://tests/helpers_test.py#L116-L127)
- [mcp_server/tests/conftest.py](file://mcp_server/tests/conftest.py#L18-L22)

## 调试技巧

### 启用详细日志

在测试中，`test_graphiti_int.py` 包含了一个 `setup_logging` 函数，用于配置日志记录器，输出详细的调试信息。

```python
def setup_logging():
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    return logger
```

### 分析LLM调用链

在 `test_comprehensive_integration.py` 中，`GraphitiTestClient` 类捕获了每个工具调用的性能指标，包括执行时间和成功状态，有助于分析LLM调用的延迟和失败情况。

### 检查图数据库状态

`helpers_test.py` 提供了 `print_graph` 函数，可以在测试过程中打印当前图数据库中的节点和边，便于调试数据状态。

```python
async def print_graph(graph_driver: GraphDriver):
    nodes, _, _ = await graph_driver.execute_query("MATCH (n) RETURN n.uuid, n.name")
    print('Nodes:')
    for node in nodes:
        print('  ', node)
    edges, _, _ = await graph_driver.execute_query("MATCH (n)-[e]->(m) RETURN n.name, e.uuid, m.name")
    print('Edges:')
    for edge in edges:
        print('  ', edge)
```

**Section sources**
- [test_graphiti_int.py](file://tests/test_graphiti_int.py#L32-L50)
- [test_comprehensive_integration.py](file://mcp_server/tests/test_comprehensive_integration.py#L75-L111)
- [helpers_test.py](file://tests/helpers_test.py#L220-L239)

## 常见错误诊断

### 连接失败

当测试无法连接到数据库时，首先检查 `docker-compose.test.yml` 文件中定义的服务是否正在运行。

```yaml
services:
  neo4j:
    image: neo4j:5.26.2
    ports:
      - "7474:7474"
      - "${NEO4J_PORT}:${NEO4J_PORT}"
```

确保环境变量（如 `NEO4J_URI`, `NEO4J_USER`, `NEO4J_PASSWORD`）已正确设置。`run_tests.py` 中的 `TestRunner` 类包含了检查数据库可用性的方法。

### 解析错误

解析错误通常发生在LLM返回的JSON格式不正确时。`test_comprehensive_integration.py` 中的 `wait_for_episode_processing` 函数包含了对JSON解析错误的异常处理。

```python
try:
    episodes = json.loads(result) if isinstance(result, str) else result
except (json.JSONDecodeError, AttributeError):
    pass
```

**Section sources**
- [docker-compose.test.yml](file://docker-compose.test.yml#L27-L40)
- [run_tests.py](file://mcp_server/tests/run_tests.py#L64-L81)
- [test_comprehensive_integration.py](file://mcp_server/tests/test_comprehensive_integration.py#L135-L140)

## 性能剖析与内存泄漏检测

`test_comprehensive_integration.py` 中的 `TestMetrics` 类用于跟踪测试操作的性能指标，包括执行时间。这有助于识别性能瓶颈。

```python
@dataclass
class TestMetrics:
    operation: str
    start_time: float
    end_time: float
    success: bool
    details: dict[str, Any]

    @property
    def duration(self) -> float:
        return self.end_time - self.start_time
```

为了检测内存泄漏，建议在长时间运行的测试中定期检查内存使用情况，并在测试前后比较图数据库的节点和边的数量。`helpers_test.py` 中的 `get_node_count` 和 `get_edge_count` 函数可用于此目的。

```python
async def get_node_count(driver: GraphDriver, uuids: list[str]) -> int:
    results, _, _ = await driver.execute_query(
        "MATCH (n) WHERE n.uuid IN $uuids RETURN COUNT(n) as count",
        uuids=uuids,
    )
    return int(results[0]['count'])
```

**Section sources**
- [test_comprehensive_integration.py](file://mcp_server/tests/test_comprehensive_integration.py#L19-L33)
- [helpers_test.py](file://tests/helpers_test.py#L192-L202)